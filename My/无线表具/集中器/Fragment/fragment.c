/* 万康自组网无线模块的参数设置与查询函数 */
/* 由采集器或集中器调用，以设置或查询自身无线模块 */
#include "fragment.h"
#include "hal.h"
#include "platform_config.h"
#include "wireless.h"
void _delay_us(u16 nUs)
{
    u16 i,j;
    for (j=0; j<nUs; j++)
    {
        i = 8;

        while(i--);
    }
}
void _delay_ms(u16 nMs)
{
    u16 i;
    for (i=0; i<nMs; i++)
    {
        _delay_us(1000);
    }
}
u8 G_CombinData[MAXPACKAGELEN]; //重组完成后的数据
FRAGMENT_HEADER sheader = {0,0,0,0,0,0,0,4,0};
COMBINE_STATUS  sSTATUS; //分片重组状况
u8 G_Max_Package[MAXPACKAGELEN]=
{
    0x68,0x20,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0x01,0xFF,0x02,0x03,0x04,0x05,0x06,
    0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,0x14,0x15,0x16,
    0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,
    0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x30,0x31,0x32,0x33,0x34,0x35,0x36,
    0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,0x40,0x41,0x42,0x43,0x44,0x45,0x46,
    0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,0x50,0x51,0x52,0x53,0x54,0x55,0x56,
    0x57,0x58,0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,0x60,0x61,0x62,0x63,0x64,0x65,0x66,
    0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,0x70,0x71,0x72,0x73,0x74,0x75,0x76,
    0x77,0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,0x80,0x81,0x82,0x83,0x84,0x85,0x86,
    0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,
    0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,
    0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,
    0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF,0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,
    0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,
    0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,
    0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0x1E,0x16,
    0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB
    ,0xBB,0xBB,0xBB,0xBB,0xCC
};


/*****************************************************************************
* Function Name  : Send_Fragment
* Description    : 将原始数据分片发送
* Input
		pOriginal: 原始数据首地址
			   nL：原始数据包长度
* Output         : None
* Return         : None
* 该函数执行时间较长，注意及时喂狗
******************************************************************************
*/
void Send_Fragment(u8* pOriginal,u16 nL)
{
    u8 i=0,j=0,cs=0,count=0;
    u8 frag_buf[MTULEN];
    static u8 Packet_Number = 1;//源数据报文编号
    sheader.meshID = 0x55555555;

    sheader.reserved1 = 0;
    sheader.reserved2 = 0;
    if(Packet_Number == 0)  Packet_Number++;//避免出现编号为0的报文
    sheader.serial_num = Packet_Number++; //源数据报文编号
    sheader.length = nL;

    count = nL/MTUDATALEN;
    if(nL%MTUDATALEN != 0)
    {
        count++;
    }
    for(i=0; i<count; i++)
    {
        sheader.index = i; //片索引
        for(j=0; j<11; j++) //首部校验和
        {
            cs += *((u8*)&sheader + j);
        }
        sheader.check = cs;
        cs = 0;

        memcpy(frag_buf,&sheader,sizeof(sheader));

        memcpy(frag_buf+sizeof(sheader),pOriginal+MTUDATALEN*i,MTUDATALEN);
        Send_UART(3,frag_buf,MTULEN);//串口3接采集器上行模块
        _delay_ms(200);
    }
}

/*****************************************************************************
* Function Name  : Combine_Fragment
* Description    : 合并分片,合并后数据存放在G_RecvData中
				   建议在串口定时器中断中调用该函数
* Input
		pFragment: 收到的分片数据
			   nL：分片的长度
* Output         : None
* Return         : None
******************************************************************************
*/
void Combine_Fragment(u8* pFragment,u8 nL)
{
    u8 i=0;
    u8 cs=0,count=0;
    u16 dataHead = 0; //分片中数据的头（在原数据包中的起始位置）
//	u8 dataLen = 0; //分片中数据的长度
    static u8 Packet_Number2 = 0;//接收端报文编号,0为未收到数据

    if(nL<12)//长度错误
    {
        sSTATUS.faultcode = ERROR_LEN;
        return;
    }

    memcpy(&sheader,pFragment,sizeof(sheader));

    sSTATUS.package_num = sheader.serial_num; //当前报文编号

    for(i=0; i<11; i++) //首部校验和
    {
        cs += *((u8*)&sheader + i);
    }
    if(sheader.check != cs)//校验和错误
    {
        sSTATUS.faultcode = ERROR_CS;
        return;
    }

    if(Packet_Number2 == 0)//开始重组新的数据包
    {
        //状态结构体置0
        memset(&sSTATUS,0,sizeof(sSTATUS));
        Packet_Number2 = sheader.serial_num;
    }

    if(Packet_Number2 != sheader.serial_num)//报文编号错误
    {
        sSTATUS.faultcode = ERROR_PACKET_Num;
        return;
    }

    sSTATUS.index = sheader.index;
    sSTATUS.received[sheader.index] = 1;

    dataHead = sheader.index * MTUDATALEN;
    count = sheader.length/MTUDATALEN;
    if(sheader.length%MTUDATALEN != 0)
    {
        count++;
    }
    sSTATUS.fragment_num = count;


    if(sheader.index == count-1)
    {
        memcpy(G_CombinData+dataHead,pFragment+12,sheader.length%MTUDATALEN);//拷贝数据
        for(i=0; i<count; i++)
        {
            if(sSTATUS.received[i] != 1) break;
        }
        if(i == count)//重组完成
        {
            sSTATUS.completed = 1;
            Packet_Number2 = 0;
            UART_4(G_CombinData,sheader.length);
        }
    }
    else
    {
        memcpy(G_CombinData+dataHead,pFragment+12,MTUDATALEN);//拷贝数据
    }

}



